#!./perl -Ilib -w

# This file should really be extracted from a .PL file

use strict;
use vars qw( %Options );
use Config;        # for config options in the makefile
#use Data::Dumper;$Data::Dumper::Indent=1;
use File::Basename qw( dirname );
use File::Spec::Functions qw(rel2abs no_upwards);
use Getopt::Long;    # for command-line parsing
use Cwd;
use Pod::Html;
use Pod::Html::Auxiliary qw(
    anchorify
    relativize_url
);


my %args = (
    podpath     => [ '.' ],
    podroot     => '.',
    htmldir     => '',
    htmlroot    => '/',
    recurse     => 0,
    splithead   => [],
    splititem   => [],
    splitpod    => '',
    verbose     => 0,
);
usage("") unless @ARGV;

# Overcome shell's p1,..,p8 limitation.  
# See vms/descrip_mms.template -> descrip.mms for invocation.
if ( $^O eq 'VMS' ) { @ARGV = split(/\s+/,$ARGV[0]); }

# parse the command-line
my $result = GetOptions( \%Options, qw(
    help
    podpath=s
    podroot=s
    htmldir=s
    htmlroot=s
    ignore=s
    recurse!
    splithead=s
    splititem=s
    splitpod=s
    verbose
));
usage("invalid parameters") unless $result;
my $parsed_args = process_options( \%Options, \%args );

# set these variables to appropriate values if the user didn't specify
#  values for them.
$parsed_args->{htmldir}  ||= "$parsed_args->{htmlroot}/html";
$parsed_args->{splitpod} ||= "$parsed_args->{podroot}/pod";

# make sure that the destination directory exists
if (! -d $parsed_args->{htmldir} ) {
    mkdir($parsed_args->{htmldir}, 0755)
        || die "$0: cannot make directory $parsed_args->{htmldir}: $!\n";
}

# the following array will eventually contain files that are to be
# ignored in the conversion process.  these are files that have been
# process by splititem or splithead and should not be converted as a
# result.
# It's important to do this before convert ANY pods because
# it may affect some of the links

$parsed_args = split_on_head( $parsed_args );
$parsed_args = split_on_item( $parsed_args );

# convert the pod pages found in @poddirs
foreach my $dir (@{$parsed_args->{podpath}}) {
    my $rv = installdir( {
      dir             => $dir,
      %{$parsed_args}
    } );
}


# now go through and create master indices for each pod we split
foreach my $dir (@{$parsed_args->{splititem}}) {
    print "creating index $parsed_args->{htmldir}/$dir.html\n" if
    $parsed_args->{verbose};
    create_index("$parsed_args->{htmldir}/$dir.html", "$parsed_args->{htmldir}/$dir");
}

foreach my $dir (@{$parsed_args->{splithead}}) {
    (my $pod = $dir) =~ s,^.*/,,;
    $dir .= ".pod" unless $dir =~ /(\.pod|\.pm)$/;
    # let pod2html create the file
    my $rv = runpod2html( {
      podfile         => $dir,
      doindex         => 1,
      %{$parsed_args},
    } );

    # now go through and truncate after the index
    $dir =~ /^(.*?)(\.pod|\.pm)?$/sm;
    my $file = "$parsed_args->{htmldir}/$1";
    print "creating index $file.html\n" if $parsed_args->{verbose};

    # read in everything until what would have been the first =head
    # directive, patching the index as we go.
    open(my $H, '<', "$file.html") ||
        die "$0: error opening $file.html for input: $!\n";
    $/ = "";
    my @data = ();
    while (<$H>) {
        last if /name="name"/i;
#            if ( ! defined $Options{htmlroot} || $Options{htmlroot} eq '' );
        $_ =~ s{href="#(.*)">}{
            my $url = "$pod/$1.html" ;
            $url = relativize_url( $url, "$file.html" )
            if ( ! defined $parsed_args->{htmlroot} || $parsed_args->{htmlroot} eq '' );
            "href=\"$url\">" ;
        }egi;
        push @data, $_;
    }
    close($H);

    # now rewrite the file
    open(my $HOUT, '>', "$file.html") ||
        die "$0: error opening $file.html for output: $!\n";
        print $HOUT "@data", "\n";
    close($HOUT);
}

##############################################################################


sub usage {
    warn "$0: @_\n" if @_;
    my $usage =<<END_OF_USAGE;
Usage: $0 --help --podpath=<name>:...:<name> --podroot=<name>
         --htmldir=<name> --htmlroot=<name> --norecurse --recurse
         --splithead=<name>,...,<name> --splititem=<name>,...,<name>
         --ignore=<name>,...,<name> --verbose

    --help      - this message
    --podpath   - colon-separated list of directories containing .pod and
                  .pm files to be converted (. by default).
    --podroot   - filesystem base directory from which all relative paths in
                  podpath stem (default is .).
    --htmldir   - directory to store resulting html files in relative
                  to the filesystem (\$podroot/html by default).
    --htmlroot  - http-server base directory from which all relative paths
                  in podpath stem (default is /).
    --norecurse - don't recurse on those subdirectories listed in podpath.
                  (default behavior).
    --recurse   - recurse on those subdirectories listed in podpath
    --splithead - comma-separated list of .pod or .pm files to split.  will
                  split each file into several smaller files at every occurrence
                  of a pod =head[1-6] directive.
    --splititem - comma-separated list of .pod or .pm files to split using
                  splitpod.
    --splitpod  - directory where the program splitpod can be found
                  (\$podroot/pod by default).
    --ignore    - comma-separated list of files that shouldn't be installed.
    --verbose   - self-explanatory.

END_OF_USAGE
    die $usage;
}

sub process_options {
    my ($Options, $args) = @_;
    my %parsed_args = ();
    usage() if defined $Options->{help};
    $Options->{help} = "";                 # make -w shut up

    while (my ($k,$v) = each %{$args}) {
        $parsed_args{$k} = $v;
    }

    # list of directories
    @{$parsed_args->{podpath}}   = split(":", $Options->{podpath}) if defined $Options->{podpath};

    # lists of files
    @{$parsed_args->{splithead}} = split(",", $Options->{splithead}) if defined $Options->{splithead};
    @{$parsed_args->{splititem}} = split(",", $Options->{splititem}) if defined $Options->{splititem};

    for my $r ( qw| htmldir htmlroot podroot splitpod recurse verbose | ) {
        $parsed_args->{$r} = $Options->{$r} if defined $Options->{$r};
    }

    @{$parsed_args->{ignore}} =
        map "$parsed_args->{podroot}/$_", split(",", $Options->{ignore})
            if defined $Options->{ignore};
    return $parsed_args;
}

sub create_index {
    my($html, $dir) = @_;
    (my $pod = $dir) =~ s,^.*/,,;

    # get the list of .html files in this directory
    opendir(my $DIR, $dir) ||
        die "$0: error opening directory $dir for reading: $!\n";
    my @files = sort(grep(/\.html?$/, readdir($DIR)));
    closedir($DIR);

    open(my $HTML, '>', $html) ||
        die "$0: error opening $html for output: $!\n";

    # for each .html file in the directory, extract the index
    #    embedded in the file and throw it into the big index.
    print $HTML "<DL COMPACT>\n";
    foreach my $file (@files) {
    
        my $fullfile = "$dir/$file";
        my $filedata = do {
            open(my $IN, '<', $fullfile) ||
            die "$0: error opening $fullfile for input: $!\n";
            local $/ = undef;
            <$IN>;
            close $IN;
        };
    
        # pull out the NAME section
        my($lcp1, $lcp2) =
            ($filedata =~
            m#<h1 id="NAME">NAME</h1>\s*<p>\s*(\S+)\s+-\s+(\S.*?\S)</p>#);
        defined $lcp1 or die "$0: can't find NAME section in $fullfile\n";
    
        my $url= "$pod/$file" ;
        if ( ! defined $Options{htmlroot} || $Options{htmlroot} eq '' ) {
            $url = relativize_url( "$pod/$file", $html ) ;
        }
    
        print $HTML qq(<DT><A HREF="$url">);
        print $HTML "$lcp1</A></DT><DD>$lcp2</DD>\n";
    }
    print $HTML "</DL>\n";

    close($HTML);
}

sub split_on_head {
    my $args = shift;
    my($pod, $dirname, $filename);
    #   my @ignoredirs = ();

    # split the files specified in @splithead on =head[1-6] pod directives
    print "splitting files by head.\n"
        if $args->{verbose} && $#{$args->{splithead}} >= 0;
    foreach $pod (@{$args->{splithead}}) {
        # figure out the directory name and filename
        $pod      =~ s,^([^/]*)$,/$1,;
        $pod      =~ m,(.*)/(.*?)(\.pod)?$,;
        $dirname  = $1;
        $filename = "$2.pod";
    
        # since we are splitting this file it shouldn't be converted.
        push(@{$args->{ignoredirs}}, "$args->{podroot}/$dirname/$filename");
    
        push(@{$args->{splitdirs}}, splitpod( {
            file        => "$args->{podroot}/$dirname/$filename",
            splitdirs   => $args->{splitdirs},
            verbose     => $args->{verbose},
        } ) );
    }
    return $args;
}

sub split_on_item {
    my $args = shift;
    my($pwd, $dirname, $filename);

    print "splitting files by item.\n"
        if $args->{verbose} && $#{$args->{splititem}} >= 0;
    $pwd = getcwd();
    my $splitter = rel2abs("$args->{splitpod}/splitpod", $pwd);
    my $perl = rel2abs($^X, $pwd);
    foreach my $pod (@{$args->{splititem}}) {
        # figure out the directory to split into
        $pod      =~ s,^([^/]*)$,/$1,;
        $pod      =~ m,(.*)/(.*?)(\.pod)?$,;
        $dirname  = "$1/$2";
        $filename = "$2.pod";
    
        # since we are splitting this file it shouldn't be converted.
        my $this_poddir = "$args->{podroot}/$dirname";
        push(@{$args->{ignore}}, "$this_poddir.pod");
    
        # split the pod
        push(@{$args->{splitdirs}}, $this_poddir);
        if (! -d $this_poddir) {
            mkdir($this_poddir, 0755) ||
                die "$0: error creating directory $this_poddir: $!\n";
        }
        chdir($this_poddir) ||
            die "$0: error changing to directory $this_poddir: $!\n";
        die "$splitter not found. Use '--splitpod dir' option.\n"
            unless -f $splitter;
        system($perl, $splitter, "../$filename") &&
            warn "$0: error running '$splitter ../$filename'"
             ." from $this_poddir";
    }
    chdir($pwd);
    return $args;
}

# splitpod - splits a .pod file into several smaller .pod files
#  where a new file is started each time a =head[1-6] pod directive
#  is encountered in the input file.

sub splitpod {
    my $args = shift;
    my $poddir = dirname($args->{file});
    my(@poddata, @filedata, @heads);
    my @splitdirs = ();

    print "splitting $args->{file}\n" if $args->{verbose};

    # read the file in paragraphs
    $/ = "";
    open(my $SPLITIN, '<', $args->{file}) ||
        die "$0: error opening $args->{file} for input: $!\n";
    @filedata = <$SPLITIN>;
    close($SPLITIN) ||
    die "$0: error closing $args->{file}: $!\n";

    # restore the file internally by =head[1-6] sections
    @poddata = ();
    my ($i, $j);
    for ($i = 0, $j = -1; $i <= $#filedata; $i++) {
        $j++ if ($filedata[$i] =~ /^\s*=head[1-6]/);
        if ($j >= 0) { 
            $poddata[$j]  = "" unless defined $poddata[$j];
            $poddata[$j] .= "\n$filedata[$i]" if $j >= 0;
        }
    }

    # create list of =head[1-6] sections so that we can rewrite
    #  L<> links as necessary.
    my %heads = ();
    for my $i (0..$#poddata) {
        $heads{anchorify($1)} = 1 if $poddata[$i] =~ /=head[1-6]\s+(.*)/;
    }

    # create a directory of a similar name and store all the
    #  files in there
    my $tmp = $args->{file};
    $tmp =~ s,.*/(.*),$1,;    # get the last part of the name
    my $dir = $tmp;
    $dir =~ s/\.pod//g;
    my $this_poddir = "$poddir/$dir";
    push(@splitdirs, $this_poddir);
    mkdir($this_poddir, 0755) ||
        die "$0: could not create directory $this_poddir: $!\n"
            unless -d $this_poddir;

    # for each section of the file create a separate pod file
    $poddata[0] =~ /^\s*=head[1-6]\s+(.*)/;
    my $section    = "";
    my $nextsec    = $1;
    my $prevsec;
    for (my $i = 0; $i <= $#poddata; $i++) {
        # determine the "prev" and "next" links
        $prevsec = $section;
        $section = $nextsec;
        if ($i < $#poddata) {
            $poddata[$i+1] =~ /^\s*=head[1-6]\s+(.*)/;
            $nextsec       = $1;
        } else {
            $nextsec = "";
        }
    
        # determine an appropriate filename (this must correspond with
        #  what pod2html will try and guess)
        # $poddata[$i] =~ /^\s*=head[1-6]\s+(.*)/;
        my $thisfile = "$dir/" . anchorify($section) . ".pod";
    
        # create the new .pod file
        my $this_podfile = "$poddir/$thisfile";
        print "\tcreating $this_podfile\n" if $args->{verbose};
        open(my $SPLITOUT, '>', $this_podfile) ||
            die "$0: error opening $this_podfile for output: $!\n";
        $poddata[$i] =~ s,L<([^<>]*)>,
                defined $heads{anchorify($1)} ? "L<$dir/$1>" : "L<$1>"
                 ,ge;
        print $SPLITOUT $poddata[$i]."\n\n";
        print $SPLITOUT "=over 4\n\n";
        print $SPLITOUT "=item *\n\nBack to L<$dir/\"$prevsec\">\n\n"
            if $prevsec;
        print $SPLITOUT "=item *\n\nForward to L<$dir/\"$nextsec\">\n\n"
            if $nextsec;
        print $SPLITOUT "=item *\n\nUp to L<$dir>\n\n";
        print $SPLITOUT "=back\n\n";
        close($SPLITOUT) ||
            die "$0: error closing $this_podfile: $!\n";
    }
    return \@splitdirs;
}

# installdir - takes care of converting the .pod and .pm files in the
#  current directory to .html files and then installing those.

sub installdir {
    my $args = shift;

    my @dirlist; # directories to recurse on
    my @podlist; # .pod files to install
    my @pmlist;  # .pm files to install

    # should files in this directory get an index?
    my $doindex = (grep($_ eq "$args->{podroot}/$args->{dir}", @{$args->{splitdirs}}) ? 0 : 1);

    opendir(my $DIR, "$args->{podroot}/$args->{dir}")
        || die "$0: error opening directory $args->{podroot}/$args->{dir}: $!\n";

    while(readdir $DIR) {
        no_upwards($_) or next;
        my $is_dir = -d "$args->{podroot}/$args->{dir}/$_";
        next if $is_dir and not $args->{recurse};
        my $target = (
            $is_dir    ? \@dirlist :
            s/\.pod$// ? \@podlist :
            s/\.pm$//  ? \@pmlist  :
            undef
        );
        push @$target, "$args->{dir}/$_" if $target;
    }

    closedir($DIR);

    if ($^O eq 'VMS') { s/\.dir$//i for @dirlist }

    # recurse on all subdirectories we kept track of
    foreach my $dir (@dirlist) {
        my $rv = installdir( {
          dir             => $dir,
          recurse         => $args->{recurse},
          podroot         => $args->{podroot},
          splitdirs       => $args->{splitdirs},
          ignore          => $args->{ignore},
          htmldir         => $args->{htmldir},
          verbose         => $args->{verbose},
          htmlroot        => $args->{htmlroot},
          podpath         => $args->{podpath},
        } );
    }

    # install all the pods we found
    foreach my $pod (@podlist) {
        # check if we should ignore it.
        next if $pod =~ m(/t/); # comes from a test file
        next if grep($_ eq "$pod.pod", @{$args->{ignore}});
    
        # check if a .pm files exists too
        if (grep($_ eq $pod, @pmlist)) {
            print  "$0: Warning both '$args->{podroot}/$pod.pod' and "
            . "'$args->{podroot}/$pod.pm' exist, using pod\n";
            push(@{$args->{ignore}}, "$pod.pm");
        }
        my $rv = runpod2html( {
          podfile         => "$pod.pod",
          podroot         => $args->{podroot},
          podpath         => $args->{podpath},
          doindex         => $doindex,
          htmldir         => $args->{htmldir},
          htmlroot        => $args->{htmlroot},
          verbose         => $args->{verbose},
          recurse         => $args->{recurse},
        } );
    }

    # install all the .pm files we found
    foreach my $pm (@pmlist) {
        # check if we should ignore it.
        next if $pm =~ m(/t/); # comes from a test file
        next if grep($_ eq "$pm.pm", @{$args->{ignore}});
    
        my $rv = runpod2html( {
          podfile         => "$pm.pm",
          podroot         => $args->{podroot},
          podpath         => $args->{podpath},
          doindex         => $doindex,
          htmldir         => $args->{htmldir},
          htmlroot        => $args->{htmlroot},
          verbose         => $args->{verbose},
          recurse         => $args->{recurse},
        } );
    }
}

# runpod2html - invokes pod2html to convert a .pod or .pm file to a .html
#  file.
# $rv = runpod2html( {
#   podfile         => $pod,
#   podroot         => $podroot,
#   podpath         => \@podpath,
#   doindex         => $doindex,
#   htmldir         => $htmldir,
#   htmlroot        => $htmlroot,
#   verbose         => $verbose,
#   recurse         => $recurse,
# } );
#
sub runpod2html {
    my $args = shift;
    my($html, $i, $dir, @dirs);

    $html = $args->{podfile};
    $html =~ s/\.(pod|pm)$/.html/g;

    # make sure the destination directories exist
    @dirs = split("/", $html);
    $dir  = "$args->{htmldir}/";
    for ($i = 0; $i < $#dirs; $i++) {
        if (! -d "$dir$dirs[$i]") {
            mkdir("$dir$dirs[$i]", 0755) ||
            die "$0: error creating directory $dir$dirs[$i]: $!\n";
        }
        $dir .= "$dirs[$i]/";
    }

    # invoke pod2html
    print "$args->{podroot}/$args->{podfile} => $args->{htmldir}/$html\n"
        if $args->{verbose};
    my $p2h = Pod::Html->new();
    my $options = {
        htmldir     => $args->{htmldir},
        htmlroot    => $args->{htmlroot},
        podpath     => join(":", @{$args->{podpath}}),
        podroot     => $args->{podroot},
        header      => 1,
        index       => ($args->{doindex} ? 1 : 0),
        recurse     => ($args->{recurse} ? 1 : 0),
        infile      => "$args->{podroot}/$args->{podfile}",
        outfile     => "$args->{htmldir}/$html",
    };
    $p2h->process_options( $options );
    $p2h->cleanup_elements();
    $p2h->generate_pages_cache();
    
    my $parser = $p2h->prepare_parser();
    $p2h->prepare_html_components($parser);

    my $output = $p2h->prepare_output($parser);
    my $rv = $p2h->write_html($output);
    die "$0: error running pod2html: $!\n" if $?;
    return $rv;
}

=head1 NAME

installhtml - converts a collection of POD pages to HTML format.

=head1 SYNOPSIS

    installhtml  [--help] [--podpath=<name>:...:<name>] [--podroot=<name>]
         [--htmldir=<name>] [--htmlroot=<name>]  [--norecurse] [--recurse]
         [--splithead=<name>,...,<name>]   [--splititem=<name>,...,<name>]
         [--ignore=<name>,...,<name>]  [--verbose]

=head1 DESCRIPTION

I<installhtml> converts a collection of POD pages to a corresponding
collection of HTML pages.  This is primarily used to convert the pod
pages found in the perl distribution.

=head1 OPTIONS

=over 4

=item B<--help> help

Displays the usage.

=item B<--podroot> POD search path base directory

The base directory to search for all .pod and .pm files to be converted.
Default is current directory.

=item B<--podpath> POD search path

The list of directories to search for .pod and .pm files to be converted.
Default is 'podroot/.'.

=item B<--recurse> recurse on subdirectories

Whether or not to convert all .pm and .pod files found in subdirectories
too.  Default is to not recurse.

=item B<--htmldir> HTML destination directory

The base directory which all HTML files will be written to.  This should
be a path relative to the filesystem, not the resulting URL.

=item B<--htmlroot> URL base directory

The base directory which all resulting HTML files will be visible at in
a URL.  The default is '/'.

=item B<--splithead> POD files to split on =head directive

Comma-separated list of pod files to split by the =head directive.  The
.pod suffix is optional. These files should have names specified
relative to podroot.

=item B<--splititem> POD files to split on =item directive

Comma-separated list of all pod files to split by the =item directive.
The .pod suffix is optional.  I<installhtml> does not do the actual
split, rather it invokes I<splitpod> to do the dirty work.  As with
--splithead, these files should have names specified relative to podroot.

=item B<--splitpod> Directory containing the splitpod program

The directory containing the splitpod program. The default is 'podroot/pod'.

=item B<--ignore> files to be ignored

Comma-separated of files that shouldn't be installed, given relative
to podroot.

=item B<--verbose> verbose output

Self-explanatory.

=back

=head1 EXAMPLE

The following command-line is an example of the one we use to convert
perl documentation:

    ./installhtml --podpath=lib:ext:pod:vms   \
            --podroot=/usr/src/perl     \
            --htmldir=/perl/nmanual     \
            --htmlroot=/perl/nmanual    \
            --splithead=pod/perlipc     \
            --splititem=pod/perlfunc    \
            --recurse \
            --verbose

=head1 AUTHOR

Chris Hall E<lt>hallc@cs.colorado.eduE<gt>

=cut

__END__
print STDERR Dumper $parsed_args;
